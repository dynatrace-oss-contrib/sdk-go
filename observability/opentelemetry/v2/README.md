# OpenTelemetry instrumentation for cloudevents

This package contains the components necessary to instrument cloudevents clients with OpenTelemetry. The main component is the `OTelObservabilityService` which implements the `ObservabilityService` interface from cloudevents.

## Getting a fully instrumented cloudevents HTTP client

If you want to get a fully instrumented HTTP client, use the helper method in the ` github.com/cloudevents/sdk-go/observability/opentelemetry/v2` module:

```go
import (
	"context"

	otelObs "github.com/cloudevents/sdk-go/observability/opentelemetry/v2/client"
	cloudevents "github.com/cloudevents/sdk-go/v2"
	"github.com/cloudevents/sdk-go/v2/client"
	cehttp "github.com/cloudevents/sdk-go/v2/protocol/http"
)

// you can pass the http/client options as usual
c, _ := otelObs.NewClientHTTP([]cehttp.Option{}, []client.Option{})

```

This will give you spans for outgoing and incoming requests. By default the spans will have the attributes as defined in [keys.go](https://github.com/cloudevents/sdk-go/blob/main/v2/observability/keys.go). For more advanced configuration, see the next section.

## Advanced configuration

### HTTP auto-instrumentation

In order to generate spans when sending and receiving events, it's necessary to configure the HTTP client from cloudevents with OpenTelemetry instrumentation. The client has two "possibilities" for instrumentation:

- Outgoing requests
- Incoming requests (via StartReceiver)

To fulfil these, we can simply use the [HTTP auto-instrumentation package](https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation/net/http/otelhttp) from OpenTelemetry:

```go

t, err := cloudevents.NewHTTP(
	cloudevents.WithRoundTripper(otelhttp.NewTransport(http.DefaultTransport)),
	cloudevents.WithMiddleware(func(next http.Handler) http.Handler {
		return otelhttp.NewHandler(next, "receive")
	}),
)
```

The `otelhttp.NewTransport` will ensure that spans are generated for each outgoing request, and that the `traceparent` header is properly propagated. The `otelhttp.NewHandler` will take care of incoming requests, reading the `traceparent` header and continuing the trace with a new span.

This already gives some observability "out-of-the-box", but the spans generated only contain common HTTP headers as defined in the [HTTP semantic conventions](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/http.md). Also if you are using another protocol, then spans will not be automatically generated, unless there is an auto-instrumentation library for that.

Because of this, cloudevents offers the `ObservabilityService` interface which is used to generate spans, independently of the chosen protocol. See next how to configure the cloudevents client to use it.


### Using the OTelObservabilityService

The most basic way to configure the cloudevents client to use the `OTelObservabilityService` is:

```go
c, err := cloudevents.NewClient(p, client.WithObservabilityService(otelObs.NewOTelObservabilityService()))

```

With the above configuration, the spans generated by the `OTelObservabilityService` will have:

- **Name**: Will be a composition of: `cloudevents.client.<event type> <operation name>`
    - `<operation name>` depends on the method being invoked and follows the OpenTelemetry [semantic conventions for messaging systems](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/messaging.md#operation-names)

- **Attributes**: The spans will always have the attributes as defined in [keys.go](https://github.com/cloudevents/sdk-go/blob/main/v2/observability/keys.go)

If you require different span names or extra attributes, you can pass multiple `OTelObservabilityServiceOption` options when creating the observability service:

```go
nameFormatter := func(e *cloudevents.Event) string {
	return "my.custom.name." + e.Context.GetType()
}

attributesGetter := func(*cloudevents.Event) []attribute.KeyValue {
	return []attribute.KeyValue{
		attribute.String("my-attr", "some-value"),
	}
}

// create the obs service with custom span names and attributes
os := otelObs.NewOTelObservabilityService(
	otelObs.WithSpanNameFormatter(nameFormatter),
	otelObs.WithSpanAttributesGetter(attributesGetter),
)

c, err := cloudevents.NewClient(p, client.WithObservabilityService(os))
```

>NOTE: The `nameFormatter` and `attributesGetter` functions will be called on each span creation, so it's recommended to not do any heavy processing in them.


## Extra types

This package also contains extra types and helper functions that are useful in case you need to access/set the `tracecontext` in a more "low-level" way.

They allow to inject(write) and extract(read) `tracecontext` from the event. This is particularly useful when dealing with code that has no notion of a "request" nor a context. For example, long-running background processes pooling from a queue. 

>Note: To learn more about the propagation, take a look at the [Propagators API SPEC](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md).


## Manually extracting/injecting tracecontext from the event

When working with distributed systems, it can be difficult to achieve proper context propagation. For example, a long-running process listening to a topic does not have a "context" concept like a HTTP server receiving requests does.

>Note: The OpenTelemetry community is always creating auto-instrumentation libraries for popular SDKs and frameworks, so there could be one for the queue client or other framework you are using. It's worth checking out what is available in the [go-contrib GitHub repository](https://github.com/open-telemetry/opentelemetry-go-contrib/tree/main/instrumentation)

For this case, it might be useful to `inject` the `tracecontext` inside the event before sending it to a queue. Later, the process can `extract` it and continue the trace normally. For that we can use the `InjectDistributedTracingExtension` and `ExtractDistributedTracingExtension` helper functions.

```go
func sendEventToQueue(ctx context.Context, event cloudevents.Event) {

    // assuming this function is properly instrumented, 
    // the ctx contains the current span

    // Before sending the event to the queue
    // we can inject the tracecontext into the event as a DistributedTracingExtension
    otelObs.InjectDistributedTracingExtension(ctx, event)
}
```

```go
func handleEvent(e cloudevents.Event) {
	// here in our long-running process, we don't have a "context"

	// if we have the tracecontext in the event, we can
	// re-create the context with it and continue the trace:
	ctx := otelObs.ExtractDistributedTracingExtension(context.Background(), e)

	// ctx now has the tracecontext from the moment when the event was sent.

	// All subsequent requests made with this context will be part of the trace.
	c, _ := otelObs.NewClientHTTP([]cehttp.Option{}, []client.Option{})
	ctx = cloudevents.ContextWithTarget(ctx, "my-other-cloudevents-app")
	c.Send(ctx, e)
}
```

Because we used the `context` that was re-created from the event, the call to `my-other-cloudevents-app` will be correlated with the initial span. If `my-other-cloudevents-app` is also instrumented and itself make more calls, these will also be part of the trace.

Most use-cases are covered by using the `InjectDistributedTracingExtension` and `ExtractDistributedTracingExtension` helper functions. Continue reading if you need more low-level detail.

### CloudEventCarrier and CloudEventTraceContext

The `CloudEventCarrier` is an implementation of the [TextMapCarrier](https://github.com/open-telemetry/opentelemetry-go/blob/main/propagation/propagation.go#L23). Its purpose is to carry the `tracecontext`, that is used by propagators later. `CloudEventCarrier` exposes the `DistributedTracingExtension` which is set by the propagator. It is similar to the [HeaderCarrier](https://github.com/open-telemetry/opentelemetry-go/blob/main/propagation/propagation.go#L44) which allows getting/setting the `traceparent` header.

The `CloudEventTraceContext` is a wrapper around the OpenTelemetry [TraceContext](https://github.com/open-telemetry/opentelemetry-go/blob/main/propagation/trace_context.go) type.

These types can be combined to get access to the "raw" `tracecontext` values (`traceparent` and `tracestate`). One use case is to set both to your custom type that you can later use to convert to a cloudevent

```go

type MyEvent struct { 
	TraceParent string `json:"traceparent,omitempty"`
	TraceState string `json:"tracestate,omitempty"`
}

func injectAndReadTraceParentAndState(ctx context.Context, e cloudevents.Event) {

    me := MyEvent{}
    tc := otelObs.NewCloudEventTraceContext()
	carrier := otelObs.NewCloudEventCarrier()

    // Injects (writes) the tracecontext into the NewCloudEventCarrier
    // Doing so, will set the DistributedTracingExtension
	tc.Inject(ctx, carrier)

    // Here then we have the "raw" access to the tracecontext data
    // https://www.w3.org/TR/trace-context/

    // e.g. 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01
	me.TraceParent = carrier.Extension.TraceParent

    // e.g. congo=t61rcWkgMzE
	me.TraceState = carrier.Extension.TraceState
}
```
